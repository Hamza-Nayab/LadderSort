Case0 = Sorted
Case 1 = Random
Case 2 = End Insertion
Case 3 = Sorted Blocks
Case 4 = Few Unique and stable groups
Case 5 = Reverse
Case 6 = 95% sorted 5% Random
Case 7 = 10 unique elements at the end.

Best Cases:
1:
og/event compaction from Kafka (or sharded logs): each partition is time-sorted, a consumer reads partitions round-robin into one file, then you need a global time sort.

Multi-sensor/time-series fusion: each sensor stream is monotone in time; a recorder multiplexes samples round-robin; later you sort by timestamp.

Inverted-index / posting-list merges: per-shard lists are sorted by docID; batches get interleaved on write; final build does a global merge-sort.

Distributed ETL/warehouse coalesce: Spark/DB partitions emit locally sorted chunks; a writer interleaves them; final compaction sorts into one ordered table.

(The “push_back(-1)” mimics a late, out-of-order record—e.g., a log with an earlier timestamp arriving after the batch.)

2: Riffle two sorted halves by coin-flip
It models two already-sorted streams randomly interleaved (e.g., merging two database partitions or two sensor/log feeds); you just need a global re-sort.
Great for run-aware merges (LadderSort, mergesort/Timsort) and for testing recovery from a late out-of-order record (your push_back(-1) step).

3: Strided-by-K from a sorted array